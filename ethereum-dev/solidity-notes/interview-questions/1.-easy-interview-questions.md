# ðŸŸ¢ 1. Easy - Interview Questions

{% embed url="https://www.rareskills.io/post/solidity-interview-questions" %}

All of these questions can be answered in three sentences or less.

### 1.1. What is the difference between private, internal, public, and external functions?

A `private` function is only accessible inside the contract in which it is defined. An `internal` function function is only accessible inside the contract in which it is defined AND inherited contracts. An `external` function is intended to be called from outside the contract in which it is defined but can be called by using `this.<FUNCTION_NAME>()`. It's used to reduce gas costs rather than to actually stop it from being called by the current contract. A `public` function is callable by anyone, anywhere.

### 1.2. Approximately, how large can a smart contract be?

Ethereum enforces a maximum contract size of 24 KB (24,576 bytes) for the bytecode of deployed contracts. This limit is meant to prevent overly large contracts from consuming excessive blockchain resources and ensure efficient validation and execution. Deploying a smart contract must fit within the block gas limit, which varies but is typically around 30 million gas on Ethereum mainnet.

E.g. A contract could have a deployed bytecode size of less than 24 KB but still use more than the block gas limit if it had complex logic in its constructor which is executed during deployment.

### 1.3. What is the difference between create and create2?

The `CREATE` opcode creates a contract at an address determined by the deployer nonce. So it is possible to know the address in advance but only if you know what the the deployer nonce will be at the time of deployment.

`CREATE2` opcode allows contracts to be deployed at a specific address derived from:

* The deployerâ€™s address.
* A salt value (a 32-byte arbitrary value provided by the deployer).
* The keccak256 hash of the contractâ€™s bytecode.

### 1.4. What major change with arithmetic happened with Solidity 0.8.0?

Over and underflow checks were added by default. The compiler now automatically reverts the transaction if an arithmetic operation results in an overflow or underflow. This enhancement makes contracts more secure by default and reduces the need for external libraries like SafeMath for these checks which were needed in previous versions.

### 1.5. What special CALL is required for proxies to work?

`delegatecall()` is used to preserve the context of a call, which is a requirement for proxy contracts.

### 1.6. How do you calculate the dollar cost of an Ethereum transaction?

Find the gas cost of the tx and multiply it by the price of Ethereum as the time of the tx.

### 1.7. What are the challenges of creating a random number on the blockchain?

A blockchain is inherently deterministic. To achieve consensus on the state of a blockchain, every node must be able to come to the same output for a given set of inputs. Therefore, true random number generation is not possible and external sources of randomness are required e.g. oracles.

### 1.8. What is the difference between a Dutch Auction and an English Auction?

A Dutch auction starts with a high price that decreases incrementally until a buyer accepts the current price, leading to a quicker sale at the first bid. In contrast, an English auction begins at a low starting price and increases with competitive bids until no higher offers are made, allowing bidders to actively compete for the highest price. The Dutch auction is faster and can prevent bidding wars, while the English auction encourages competition and transparency in price discovery.

### 1.9. What is the difference between transfer and transferFrom in ERC20?

In the ERC20 standard, `transfer` allows a token holder to send tokens directly to another address, reducing the balance of the sender and increasing the balance of the recipient. `transferFrom` facilitates token transfers on behalf of a third party, requiring prior approval via `approve` for the spender to move a specified number of tokens from the ownerâ€™s account. This makes `transferFrom` useful for use cases like escrow services or delegated transfers where a contract or user acts on behalf of another.

### 1.10. Which is better to use for an address allowlist: a mapping or an array?

Mapping. A mapping allows constant-time (O(1)) lookups and is much more efficient for regular checks like allowlists. If a user is on the allowlist, simply set their address value in the mapping to be `true` and it will be fast and gas efficient to check. To check if a user is in an array, the entire array may need to be processed, which means that the gas costs of interacting with the contract will grow exponentially with the size of the allow list array.

### 1.11. Why shouldnâ€™t tx.origin be used for authentication?

If a contract uses `tx.origin` to authenticate an address then it is vulnerable to being manipulated by a malicious man-in-the-middle contract. If a malicious contract can pass through the `tx.origin` then it could call a function e.g. an NFT transfer, without the explicit consent of the owner. This is why `msg.sender` is more secure as the context is the address of the contract that directly called the function, unless `delegatecall()` has been used.

### 1.12. What hash function does Ethereum primarily use?

keccak256. This is a variant of the SHA-3 family but differs slightly from the finalized NIST standard version of SHA-3. The keccak256 function is used in various core aspects of Ethereum, such as generating addresses, creating unique identifiers, and verifying data integrity within smart contracts.

### 1.13. How much is 1 gwei of Ether? How much is 1 wei of Ether?

`1 Gwei = 0.000000001 ETH`

`1 Wei = 0.000000000000000001 ETH`

[https://eth-converter.com](https://eth-converter.com/)

### 1.14. What is the difference between assert and require?

`require` is used to validate conditions that are expected to be true under normal circumstances, such as function input validation or checking contract state. It is typically used for user input, contract interaction conditions, and external calls. If the condition fails, `require` will revert the transaction and return any remaining gas to the caller. `require` can include a custom error message that is returned when the condition fails, making it easier to debug and understand why the transaction reverted.

`assert` is used to test for internal errors and invariants within the code that should never fail. It checks conditions that, if broken, indicate a bug in the contract. Unlike `require`, `assert` is used for validating assumptions that should always hold true in the contract logic. If an `assert` statement fails, it consumes all the gas provided for the transaction. `assert` does not provide an error message, so debugging is more difficult. It is meant for cases where a failure indicates a severe bug.

### 1.15. What is a flash loan? What is the check-effects-interaction pattern?



### 1.16. What is the minimum amount of Ether required to run a solo staking node?



### 1.17. What is the difference between fallback and receive?



### 1.18. What is reentrancy?



### 1.19. What prevents infinite loops from running forever?



### 1.20. What is the difference between tx.origin and msg.sender?



### 1.21. How do you send Ether to a contract that does not have payable functions, or a receive or fallback?



### 1.22. What is the difference between view and pure?



### 1.23. What is the difference between transferFrom and safeTransferFrom in ERC721?



### 1.24. How can an ERC1155 token be made into a non-fungible token?



### 1.25. What is access control and why is it important? What does a modifier do?



### 1.26. What is the largest value a uint256 can store?



### 1.27. What is variable and fixed interest rate?

