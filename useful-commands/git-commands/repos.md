# Repos

<figure><img src="../../.gitbook/assets/image (1).png" alt=""><figcaption></figcaption></figure>

<table data-full-width="true"><thead><tr><th>Description</th><th>Commands</th></tr></thead><tbody><tr><td><p>Clone an existing repo</p><ul><li>Add <code>.</code> at the end to clone into the current directory</li></ul></td><td><p><code>git clone &#x3C;REMOTE_REPO_URL></code></p><p><code>git clone &#x3C;REMOTE_REPO_URL> .</code></p></td></tr><tr><td>Show a list of all remote git repos (e.g. Heroku, GitHub and Bitbucket)</td><td><code>git remote -v</code></td></tr><tr><td><p>Add a remote repo</p><ul><li>Remote name is usually â€œorigin", but can be whatever you want</li></ul></td><td><code>git remote add &#x3C;REMOTE_NAME> &#x3C;REMOTE_LINK></code></td></tr><tr><td><p>Initialise new local rep</p><ul><li>Default initial branch is now called <code>main</code></li></ul></td><td><code>git init</code></td></tr><tr><td>Change the name of the recently created branch</td><td><code>git branch -m &#x3C;NAME></code></td></tr><tr><td><p>Fetch data from a remote repo</p><ul><li>Downloads any changes from the remote repository to the local remote branch copy e.g. <code>origin/main</code></li><li><code>git fetch</code> will not change anything about your local state. It will not update your main branch or change anything about how your file system looks right now.</li><li>This is important to understand because a lot of developers think that running git fetch will make their local work reflect the state of the remote. It may download all the necessary data to do that, but it does not actually change any of your local files.</li><li>Think of running <code>git fetch</code>  as a download step.</li></ul></td><td><p><code>git fetch</code><br></p><p><code>git fetch &#x3C;REMOTE_NAME> &#x3C;REF></code></p><p><code>git fetch &#x3C;REMOTE_NAME> &#x3C;SOURCE_REF>:&#x3C;DESTINATION_REF></code><br><br><code>&#x3C;EMPTY SOURCE_REF CREATES BRANCH ON LOCAL></code></p><p><code>git fetch &#x3C;REMOTE_NAME> :&#x3C;DESTINATION_REF></code></p></td></tr><tr><td><p>Working with remote repos</p><ul><li><p>Once you have new commits available locally (using <code>git fetch</code>), you can incorporate them as if they were just normal commits on other branches. This means you could execute commands like:</p><ul><li><code>git cherry-pick origin/main</code></li><li><code>git rebase origin/main</code></li><li><code>git merge origin/main</code></li></ul></li></ul></td><td><p><code>git checkout &#x3C;REMOTE_NAME>/&#x3C;BRANCH_NAME></code></p><p><code>git checkout origin/main</code></p></td></tr><tr><td><p>Fetch and merge</p><ul><li><p>The same as doing these two commands sequentially:</p><ul><li><code>git fetch</code></li><li><code>git merge origin/main</code></li></ul></li><li><code>git pull</code> is essentially shorthand for a <code>git fetch</code> followed by a merge of whatever branch was just fetched</li><li><code>--rebase</code> is shorthand for <code>fetch</code> then <code>rebase</code></li></ul></td><td><p><code>git pull</code></p><p><code>git pull --rebase</code></p><p><code>git pull &#x3C;REMOTE_NAME> &#x3C;REF></code></p><p><code>git pull &#x3C;REMOTE_NAME> &#x3C;SOURCE_REF>:&#x3C;DESTINATION_REF></code></p></td></tr><tr><td><p>Pushing changes to a remote</p><ul><li><p>Check default behaviour in git settings <code>push.default</code></p><ul><li><code>upstream</code> is a standard default option but look at other types</li></ul></li><li><p><code>-u</code> flag adds a tracking reference to the upstream server you are pushing to</p><ul><li>What is important here is that this lets you do a git pull without supplying any more arguments. For example, once you do a <code>git push -u origin main</code>, you can later call <code>git pull</code> and git will know that you actually meant <code>git pull origin main</code></li></ul></li><li><p><code>&#x3C;SOURCE_REF>:&#x3C;DESTINATION_REF></code> can be used when the source reference is different from the destination reference</p><ul><li>This could be if you wanted to push all the commits before your current commit in a feature branch straight to main</li><li>If the <code>&#x3C;DESTINATION_REF></code> doesn't exits on the remote, then git will try to create a new branch with that name</li></ul></li></ul></td><td><p><code>git push -u &#x3C;REMOTE_NAME> &#x3C;BRANCH_NAME></code></p><p><code>git push &#x3C;REMOTE_NAME> &#x3C;SOURCE_REF>:&#x3C;DESTINATION_REF></code></p><p><br><code>&#x3C;WHEN LOCAL IS BEHIND REMOTE &#x26; PUSH FAILS></code></p><p><code>git fetch</code></p><p><code>git rebase origin/maingit push -u &#x3C;REMOTE_NAME> &#x3C;BRANCH_NAME></code><br><br><code>&#x3C;EMPTY SOURCE_REF DELETES BRANCH ON REMOTE></code></p><p><code>git push &#x3C;REMOTE_NAME> :&#x3C;DESTINATION_REF></code></p></td></tr><tr><td><p>Stash changes when you want to switch to a new branch but don't want to commit the current changes</p><ul><li>Add <code>drop</code> to delete the last stash if you don't want it any more</li><li>Repeat the command for each stash</li></ul></td><td><p><code>git stash</code></p><p><code>git stash drop</code></p></td></tr><tr><td><p>Templates</p><ul><li>If a repo is based on a template, you can pull changes from the template</li><li>Fetch all the changes</li><li>Then merge the changes with the current repo</li></ul></td><td><p><code>git remote add template [URL of the template repo]</code></p><p><code>git fetch --all</code></p><p><code>git merge --allow-unrelated-histories template/[branch to merge]</code></p></td></tr></tbody></table>
